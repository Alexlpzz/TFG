# -*- coding: utf-8 -*-
"""TFG 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10EG_ifGkcoNe80w6uj2NCKvMlM-c71GQ

##Initialize enviroment
"""

import argparse

import numpy as np

import matplotlib.pyplot as plt

import scipy.stats as spyce

from scipy.integrate import quad

from scipy.optimize import fsolve

from scipy.interpolate import make_interp_spline

from scipy.optimize import bisect

from google.colab import drive
drive.mount('/content/drive')

"""#Chamber and Target Geometry

<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/IMG_0446-Photoroom.png" alt="Imagen 1" width="400">
<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/IMG_0445-Photoroom.png" alt="Imagen 2" width="500">



"""

########################################
# 1. Import Chamber and Target geometry
########################################

"argparse.Namespace is a simple container that holds attributes, typically used to store command-line arguments."
"It allows direct attribute access using dot notation, simplifying later references to those values."

chamber  =  argparse.Namespace(center=np.array([0,0]),radius=5)                      #Chamber Data
target   =  argparse.Namespace(center=np.array([0,0]),radius=1.6285e-3)              #Target  Data
window   =  argparse.Namespace(length = 0.20,)                                       #Window  Data


objective_point_1 = np.array( [-0.01060559 ,-0.02747151] )
objective_point_2 = np.array( [-0.0106718  ,-0.01853659] )
objective_point_3 = np.array( [-0.01989281 ,-0.02131562])
objective_point_4 = np.array( [-0.02083488 ,-0.01867932] )






ring1=argparse.Namespace(theta=np.radians(22.5) ,beams=4, point=objective_point_1,color='green' )    #Ring 1 Data
ring2=argparse.Namespace(theta=np.radians(30)   ,beams=4, point=objective_point_2,color='red'   )    #Ring 2 Data
ring3=argparse.Namespace(theta=np.radians(44.5) ,beams=8, point=objective_point_3,color='violet')    #Ring 3 Data
ring4=argparse.Namespace(theta=np.radians(50)   ,beams=8, point=objective_point_4,color='blue'  )    #Ring 4 Data


rings = [ring1, ring2, ring3, ring4]                                                                 #Ring List


##################################################
# 2. Calculation of the rings center and extremes.
##################################################

for ring in rings:

    ring.center=chamber.radius*np.array([ np.sin(ring.theta),np.cos(ring.theta)])
    n  = ring.center - chamber.center
    d  = np.array( [ n[1], -n[0], ])
    d /= np.linalg.norm(d)

    ring.xp = ring.center + window.length * d                                   #Lower Extreme
    ring.xm = ring.center - window.length * d                                   #Upper Extreme

"""## Graphic representation"""

#################################
# 3. Graphic aspect configuration
#################################

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_aspect( 'equal', )

ax1.set_xlim( 0, chamber.radius )                                               #Figure 1 x limit
ax1.set_ylim( 0, chamber.radius )                                               #Figure 1 y limit
ax2.set_xlim( -target.radius, target.radius*2 )                                 #Figure 2 x limit
ax2.set_ylim( -target.radius, target.radius*2 )                                 #Figure 2 y limit

plt.ylabel("z")
plt.xlabel("r")


chamber2d  =  plt.Circle  ( chamber.center  ,chamber.radius  ,fill=True   ,color='yellow'   ,alpha=0.2 )      #Chamber representation
target2d   =  plt.Circle  ( target.center   ,target.radius   ,fill=True   ,color='black'    ,alpha=1   )      #Target  representation

ax1.add_patch( chamber2d )
ax2.add_patch( target2d  )


########################################
# 4. Representation of calculated points
########################################

for ring in rings:

  ax1.plot    ( [ring.xp[0]  ,ring.point[0]]  ,[ring.xp[1]  ,ring.point[1]]  ,color=ring.color )             #Lower Laser representation
  ax1.plot    ( [ring.xm[0]  ,ring.point[0]]  ,[ring.xm[1]  ,ring.point[1]]  ,color=ring.color )             #Upper Laser representation

  ax1.scatter ( ring.center[0]  ,ring.center[1]  ,color='red'  ,marker='D'  ,s=5 )                           #Rings Centers
  ax1.scatter ( ring.xp[0]      ,ring.xp[1]      ,color='blue' ,marker='P'  ,s=5 )                           #Lower Extreme
  ax1.scatter ( ring.xm[0]      ,ring.xm[1]      ,color='blue' ,marker='P'  ,s=5 )                           #Upper Extreme

  ax2.plot    ( [ring.xp[0]  ,ring.point[0]]  ,[ring.xp[1]  ,ring.point[1]]  ,color=ring.color )             #Lower Laser representation
  ax2.plot    ( [ring.xm[0]  ,ring.point[0]]  ,[ring.xm[1]  ,ring.point[1]]  ,color=ring.color )             #Upper Laser representation

  ax1.set_title('REPRESENTACION EN 2 DIMENSIONES')

"""##INTENSITY DISTRIBUTION

<div style="display: flex; align-items: center;">
  <div style="flex: 1;">
    <img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-03-23%20125713-Photoroom.png" alt="Imagen" style="max-width: 100%;">
  </div>
  <div style="flex: 1; padding-left: 20px;">
    <p>
     The laser wavefront does not exhibit a uniform energy distribution; instead, it follows a normal (Gaussian) distribution. This means that the beam’s intensity is highest at the center and gradually decreases toward the edges, influencing how the energy is focused and utilized in various applications.
    </p>
  </div>
</div>
"""

##########################
# 5. Discretization Points
##########################

"The number of points will largely determine the precision and speed of the program."
"The greater the number of discretizations, the closer it will be to reality;"
"however, this comes at the cost of increased execution time."

discret_points   = 400                                                      #Discretitation points each ring
np.save('/content/drive/MyDrive/num_discretizado.npy', discret_points)
##########################################
# 6. Parameters of the normal distribution.
##########################################

mu               = 0
sigma            = 0.7

dist =lambda x : spyce.gennorm.pdf(x,3,loc=mu, scale=sigma)                     #Normal Function that represents Wave Front

#######################################################
# 7. Graphic representation of the normal distribution.
#######################################################

form = np.linspace(-1, 1, discret_points)                                       #Normal function between (-1,1)

plt.figure    (figsize=(8, 5))
plt.plot      (form,dist(form), color='green')

plt.xlabel    ('x')
plt.ylabel    ('intensity')
plt.title     ('intensity distribution from one beam')
plt.grid      (True)

plt.show()

"""#Calculous of dicretization distribution

For the integration we will use dimensionless variables, then $x \in [-1,1]$ will be the variable which will span the illumination region.

Laser beam has a cylindrival symmetry, then the illumination is emmited from a conical surface arround the axis.

\begin{align}
E & = \int_{S} IdS \\
& = \int_{z_{lo}}^{z_{hi}} 2 \pi r(z) I(z) dz
\end{align}

We parametrize the cone directix and we substitute in the integral.

\begin{align}
r &= \frac{r_{lo} + r_{hi}}{2} + \frac{r_{hi}-r_{lo}}{2} \omega \\
z &= \frac{z_{lo} + z_{hi}}{2} + \frac{z_{hi}-z_{lo}}{2} \omega
\end{align}

for $\omega \in [-1,1]$. We will call $\alpha = (r_{lo} + r_{hi})/2$ and $\beta = (r_{hi} - r_{lo})/2$, then $r = \alpha + \beta \omega$.

\begin{align}
\frac{E}{2 \pi} &= \int_{r_{lo}}^{r_{hi}} r I(r) dr \\
&= \int_{-1}^{1} \left( \alpha + \beta \omega \right) I(\omega) \beta d \omega \\
\frac{E}{2 \pi \beta} &= \int_{-1}^{1} \left( \alpha + \beta \omega \right) I(\omega) d \omega
\end{align}
"""

#######################################################
# 8. Discretization definition and initial parameters.
#######################################################

laser_discretitation  =  discret_points                                         #Total discretization points

alpha_r  =  ((ring.xp[0]+ring.xm[0])/2)                                         #Direction center
betha_r  =  ((ring.xp[0]-ring.xm[0])/2)                                         #Amplitude

a=-1;  b=1                                                                      #Domain limits

f1  =  dist                                                                     #Call to normal
f2  =  lambda x: (alpha_r+betha_r*x)*f1(x)                                      #Combination of the normal and the lineal factor

############################################
# 9. Calculus of total area and sector area.
############################################

total_area    =     quad(f2,a,b, limit=100, )[0]                                #Total area under the curve
area_sectors  =     total_area/(laser_discretitation-1)                         #Area of each sector

####################################
# 10. Initializing the cutoff points.
####################################

puntos_corte  =     [a]                                                         #List ,with initial value -1

###############################
# 11. Cumulative area function.
###############################

def area_acumulada(x, x0, area_objetivo):
    area, _ = quad(f2, x0, x)
    return area - area_objetivo

####################################
# 12. Calculus of new cutoff points.
####################################

"The algorithm starts at x = a (e.g., -1) and computes the target area per sector by dividing the total area under f2(x) over [-1,1]."
"Then, using fsolve, it finds the next cut point x such that the integral of f2 from the previous cut to x equals the target area."
"This process repeats to partition [-1,1] into segments of equal area, ensuring uniform distribution."

for i in range(laser_discretitation - 1):

    x0 =  puntos_corte[-1]
    x1 =  fsolve(area_acumulada, x0 + (b - a) / laser_discretitation, args=(x0, area_sectors))[0]
    puntos_corte.append(x1)

puntos_corte[-1] = 1


plt.scatter(puntos_corte, [0] * len(puntos_corte), color='red', marker='o')
np.save('/content/drive/MyDrive/vector_discretizado.npy', puntos_corte)         #Save for later use

###############################################
# 13. Integrate the discretization in each ring
###############################################

for ring in rings:

  ring.Alpha_r=((ring.xp[0]+ring.xm[0])/2)
  ring.Betha_r=((ring.xp[0]-ring.xm[0])/2)

  ring.Alpha_z=((ring.xp[1]+ring.xm[1])/2)
  ring.Betha_z=((ring.xp[1]-ring.xm[1])/2)

  ring.R=ring.Alpha_r+ring.Betha_r*np.array(puntos_corte)
  ring.Z=ring.Alpha_z+ring.Betha_z*np.array(puntos_corte)

##########################################
# 14. Graphic representation of the Laser
##########################################

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))
ax1.set_aspect( 'equal', )

ax1.set_xlim( 0, chamber.radius )
ax1.set_ylim( 0, chamber.radius )
ax2.set_xlim( -target.radius*2, target.radius*2 )
ax2.set_ylim( -target.radius*2, target.radius*2 )

plt.ylabel("z")
plt.xlabel("r")


chamber2d  =  plt.Circle( chamber.center ,chamber.radius  ,fill=True  ,color='yellow'  ,alpha=0.2 )
target2d   =  plt.Circle( target.center  ,target.radius   ,fill=True  ,color='skyblue' ,alpha=1   )

ax1.add_patch( chamber2d )
ax2.add_patch( target2d )


for ring in rings:

  for i in range(len(ring.R)):

    ax1.plot([ring.R[i],ring.point[0]],[ring.Z[i],ring.point[1]],color=ring.color)
    ax2.plot([ring.R[i],ring.point[0]],[ring.Z[i],ring.point[1]],color=ring.color)

  ax1.set_title('REPRESENTACION EN 2 DIMENSIONES')

"""##INTERSECTION POINTS

"""

laser=argparse.Namespace()                                                      #New folder

for ring in rings:

  ring.vx=np.array(ring.point[0]-ring.R)
  ring.vy=np.array(ring.point[1]-ring.Z)

########################################
# 15. Direction Vectors and Data Matrix
########################################

laser.vx  =   np.concatenate ([ ring.vx for ring in rings ])
laser.vy  =   np.concatenate ([ ring.vy for ring in rings ])
laser.R   =   np.concatenate ([ ring.R for ring in rings  ])
laser.Z   =   np.concatenate ([ ring.Z for ring in rings  ])

matriz=np.column_stack((laser.R,laser.Z,laser.vx,laser.vy))

##########################
# 16. Intersecion Function
##########################

def vector_circle_intersection(x0, y0, vx, vy, xc, yc, R):

    a = vx**2 + vy**2                                                           #Coeficients for the cuadratic ecuation
    b = 2 * (vx * (x0 - xc) + vy * (y0 - yc))
    c = (x0 - xc)**2 + (y0 - yc)**2 - R**2

    disc = b**2 - 4 * a * c                                                     #Discriminant Calculus

    if disc < 0:
        return []                                                               #No intersecion

    sqrt_disc = np.sqrt(disc)                                                   #Solutions for t
    t1 = (-b + sqrt_disc) / (2 * a)
    t2 = (-b - sqrt_disc) / (2 * a)

    points = []

    if t1 >= 0:                                                                 #Check if t1 is a valid solution
        x_inter1 = x0 + t1 * vx
        y_inter1 = y0 + t1 * vy
        points.append((x_inter1, y_inter1))

    if t2 >= 0:                                                                 #Check if t2 is a valid solution
        x_inter2 = x0 + t2 * vx
        y_inter2 = y0 + t2 * vy
        points.append((x_inter2, y_inter2))

    return points

#############################
# 17. Define target variables
#############################

xc,yc=target.center[0],target.center[1]
R=target.radius
intersection_x = []
intersection_y = []

for ring in rings:                                                              #Inicialize the list
    ring.intersection_x = []
    ring.intersection_y = []

rows_per_ring = laser_discretitation                                            #Number of files per ring

############################################################
# 18. Operate the function and obtain the interaction points
############################################################

for i, vector in enumerate(matriz):
    x0, y0, vx, vy = vector                                                     #Unpack Values

    ring_index = i // rows_per_ring
    if ring_index >= len(rings):
        break

    ring = rings[ring_index]

    intersection_points_target = vector_circle_intersection(x0, y0, vx, vy, xc, yc, R)

    "The cuadratic ecuation may has two solutions, we only want the first one, the nearest from the ring"

    if intersection_points_target:

        first_intersection = min(intersection_points_target, key=lambda p: (p[0] - x0)**2 + (p[1] - y0)**2)

        ring.intersection_x.append(first_intersection[0])
        ring.intersection_y.append(first_intersection[1])

#######################################################
# 19. Graphic representation of the Intersection Points
#######################################################

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 20))

ax1.set_aspect( 'equal', )
ax2.set_aspect( 'equal', )

ax1.set_xlim( 0, target.radius+target.radius*0.2 )
ax1.set_ylim( 0, target.radius+target.radius*0.2  )
ax2.set_xlim( -target.radius*1.2 , target.radius*1.2 )
ax2.set_ylim( -target.radius*1.2 , target.radius*1.2 )

plt.ylabel("z")
plt.xlabel("r")

target2d    =  plt.Circle(target.center  ,target.radius  ,fill=True  ,color='skyblue'  ,alpha=1)
target2d2   =  plt.Circle(target.center  ,target.radius  ,fill=True  ,color='skyblue'  ,alpha=1)

ax1.add_patch( target2d )
ax2.add_patch( target2d2 )

for ring in rings:
  ax1.scatter(ring.intersection_x,ring.intersection_y,color=ring.color,marker='+',s=30)
  ax2.scatter(ring.intersection_x,ring.intersection_y,color=ring.color,marker='+',s=10)

######################################################################
# 20. Graphic representation of the Intersection Points from each beam
######################################################################

fig, axs = plt.subplots(2, 2, figsize=(10, 10))

for ax in axs.flat:                                                             #Graphic configuration for each graphic

    ax.set_aspect    ('equal')
    ax.set_xlim      (-target.radius * 1.2, target.radius * 1.2)
    ax.set_ylim      (-target.radius * 1.2, target.radius * 1.2)
    ax.set_xlabel    ("r")
    ax.set_ylabel    ("z")

for ax in axs.flat:                                                             #Add the target to all the graphics

    target2d = plt.Circle(target.center, target.radius, fill=True, color='skyblue', alpha=1)
    ax.add_patch(target2d)

for i, ring in enumerate(rings):

    row, col = divmod(i, 2)
    ax       = axs[row, col]

    ax.scatter(ring.intersection_x, ring.intersection_y, color=ring.color, marker='+', s=5)

plt.tight_layout()
plt.show()

"""#SYMMETRIES



"""

fig, ax = plt.subplots(figsize=(8, 8))

target2d  =  plt.Circle (target.center  ,target.radius  ,fill=True  ,color='skyblue'  ,alpha=1)

ax.add_patch    (target2d)
ax.set_aspect   ('equal')

ax.set_xlim     (-target.radius * 1.2, target.radius * 1.2)
ax.set_ylim     (-target.radius * 1.2, target.radius * 1.2)

plt.ylabel      ("z")
plt.xlabel      ("r")

###############################
# 21. Calculation of symmetries
###############################

for ring in rings:

 ring.intersection_y = np.array(ring.intersection_y, dtype=float)
 ring.intersection_x = np.array(ring.intersection_x, dtype=float)

 ring.X_sym_x=ring.intersection_x                                               #X Symmetry
 ring.Y_sym_x=(-1)*ring.intersection_y

 ring.X_sym_y=(-1)*ring.intersection_x                                          #Y Symmetry
 ring.Y_sym_y=ring.intersection_y

 ring.X_sym_o=(-1)*ring.intersection_x                                          #Origin Symmetry
 ring.Y_sym_o=(-1)*ring.intersection_y


 plt.scatter  ( ring.intersection_x,  ring.intersection_y,  color=ring.color,  marker='+',  s=5)

 plt.scatter  ( ring.X_sym_x,  ring.Y_sym_x,  color=ring.color,  marker='*',  s=5)
 plt.scatter  ( ring.X_sym_y,  ring.Y_sym_y,  color=ring.color,  marker='+',  s=5)
 plt.scatter  ( ring.X_sym_o,  ring.Y_sym_o,  color=ring.color,  marker='+',  s=5)

"""#DEPOSICIÓN OF ENERGY
<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/png-transparent-diffuse-reflection-optics-diffuser-lambert-s-cosine-law-light-reflect-Photoroom.png" alt="Imagen 1" width="400">
The cosine effect describes how the effective energy of an incident beam decreases as its angle from the normal increases. Essentially, when a beam strikes a surface obliquely, the energy is spread over a larger area, so the effective intensity is reduced by a factor of cos(θ). In other words, a beam hitting the surface perpendicularly (θ = 0°) deposits maximum energy, while more oblique angles result in lower energy deposition.
"""

##################################
# 22. Calculation of laser energy
##################################

Laser_energy=9                                                                  #Energy per beam

for ring in rings:

    ring.energy_total = Laser_energy * ring.beams
    ring.energy_per_point = []

    for ix, iy in zip(ring.intersection_x, ring.intersection_y):

        beam_vec        = ring.point - np.array([ix, iy])
        beam_vec_norm   = np.linalg.norm(beam_vec)
        beam_dir        = beam_vec / beam_vec_norm if beam_vec_norm != 0 else np.array([0, 0])

        normal          = np.array([ix, iy]) - target.center
        normal_norm     = np.linalg.norm(normal)
        normal_unit     = normal / normal_norm if normal_norm != 0 else np.array([0, 0])


        cos_incidence   = abs(np.dot(beam_dir, normal_unit))                    #Factor of cos
        energy_point    = (ring.energy_total / laser_discretitation) * cos_incidence

        ring.energy_per_point.append(energy_point)

##################################
# 23. Rearrange in the same list
##################################

intersecciones = []
energias       = []

for ring in rings:
                                                                                #Original Points
    for x, y in zip(ring.intersection_x, ring.intersection_y):
        intersecciones.append((x, y))
        energias.append(ring.energy_per_point)

                                                                                #X Symmetry
    for x, y in zip(ring.X_sym_x, ring.Y_sym_x):
        intersecciones.append((x, y))
        energias.append(ring.energy_per_point)

                                                                                #Y Symmetry
    for x, y in zip(ring.X_sym_y, ring.Y_sym_y):
        intersecciones.append((x, y))
        energias.append(ring.energy_per_point)

                                                                                #Origin Symmetry
    for x, y in zip(ring.X_sym_o, ring.Y_sym_o):
        intersecciones.append((x, y))
        energias.append(ring.energy_per_point)

############################################################
# 24. Rearrange energy lists and intersections for each ring
############################################################

                                                                                #Crate empty lists
intersecciones_rings  = [[] for _ in rings]
energias_rings        = [[] for _ in rings]

                                                                                #Fill the lists
for ring_index, ring in enumerate(rings):
                                                                                #Original points
    for i, (x, y) in enumerate(zip(ring.intersection_x, ring.intersection_y)):
        intersecciones_rings[ring_index].append((x, y))
        energias_rings[ring_index].append(ring.energy_per_point[i])

                                                                                #x Symmetry
    for i, (x, y) in enumerate(zip(ring.X_sym_x, ring.Y_sym_x)):
        intersecciones_rings[ring_index].append((x, y))
        energias_rings[ring_index].append(ring.energy_per_point[i])

                                                                                #Y Symmetry
    for i, (x, y) in enumerate(zip(ring.X_sym_y, ring.Y_sym_y)):
        intersecciones_rings[ring_index].append((x, y))
        energias_rings[ring_index].append(ring.energy_per_point[i])

                                                                                #Origin Symmetry
    for i, (x, y) in enumerate(zip(ring.X_sym_o, ring.Y_sym_o)):
        intersecciones_rings[ring_index].append((x, y))
        energias_rings[ring_index].append(ring.energy_per_point[i])

                                                                                #Show the intersection from each ring
for i, (inter, ener) in enumerate(zip(intersecciones_rings, energias_rings)):
    print(f"Ring {i+1}: {len(inter)} intersecciones registradas")

"""#ENERGÍA DEPOSITED"""

############################################################
# 25. Calculation of the energy deposited on the surface
############################################################

all_points   = []                                                               #Empty lists
all_energies = []

for intersecciones, energias in zip(intersecciones_rings, energias_rings):

    all_points.extend(intersecciones)                                           #Add intersections from all rings
    all_energies.extend(energias)                                               #Add energies from all rings

all_points   = np.array(all_points)
all_energies = np.array(all_energies)


angles = (90 - np.degrees(np.arctan2(all_points[:,1], all_points[:,0]))) % 360


sector_start     = 0                                                            #Sector limits
sector_end       = 90
num_subsectores  = 20                                                           #Sector divisisions

np.save('/content/drive/MyDrive/subsectores.npy'  , num_subsectores  )          #Save for later use

subsector_limits = np.linspace(sector_start, sector_end, num_subsectores + 1)


mask_sector             = (angles >= sector_start) & (angles < sector_end)      #Filter points that fall within the first sector
angles_sector           = angles[mask_sector]
energies_sector         = all_energies[mask_sector]
intersecciones_sector_1 = all_points[mask_sector]


energy_per_subsector    = np.zeros(num_subsectores)                             #Energy per subsector


for i in range(num_subsectores):                                                #Calculate energy per subsector

    mask_sub = (angles_sector >= subsector_limits[i]) & (angles_sector < subsector_limits[i+1])
    energy_per_subsector[i] = np.sum(energies_sector[mask_sub])


for i in range(num_subsectores):
    print(f"Subsector {i+1} ({subsector_limits[i]:.1f}° a {subsector_limits[i+1]:.1f}°): Energía total = {energy_per_subsector[i]:.6f} J")

plt.figure(figsize=(8, 6))

for i in range(len(subsector_limits) - 1):
    plt.bar(subsector_limits[i],
            energy_per_subsector[i],
            width=subsector_limits[i+1] - subsector_limits[i],
            align='edge',
            color='orange',
            edgecolor='black')


plt.xlabel("Ángulo del subsector (°)")
plt.ylabel("Energía total depositada (J)")
plt.title("Distribución de energía por subsector (primer sector)")
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.xticks(subsector_limits, [f"{int(ang)}°" for ang in subsector_limits])
plt.tight_layout()
plt.show()

"""#Intesity distribution"""

############################################################
# 25. Calculation of the intensity deposited on the surface
############################################################

area_subsectores = []                                                           #Empty list

for i in range(len(subsector_limits) - 1):                                      #Calculation of area per subsector

    theta1 = np.deg2rad(subsector_limits[i])
    theta2 = np.deg2rad(subsector_limits[i+1])

    area = 2 * np.pi * target.radius**2 * (np.cos(theta1) - np.cos(theta2))
    area_subsectores.append(area)



intensity_per_sector = []                                                       #Empty list

for i in range(num_subsectores):                                                #Calculation of intensity per subsector
    intensidad = energy_per_subsector[i] / area_subsectores[i]
    intensity_per_sector.append(intensidad)
    print(intensity_per_sector[i])

variabilidad_std = np.std(intensity_per_sector)
print(f"Desviación estándar de la intensidad: {variabilidad_std:.6e} J/m²")

plt.figure(figsize=(8, 6))

for i in range(len(subsector_limits) - 1):
    plt.bar(subsector_limits[i],
            intensity_per_sector[i],
            width=subsector_limits[i+1] - subsector_limits[i],
            align='edge',
            color='orange',
            edgecolor='black')


plt.xlabel("Ángulo del subsector (°)")
plt.ylabel("Intensidad (J/m²)")
plt.title("Distribución de intensidad por subsector (primer sector)")
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.xticks(subsector_limits, [f"{int(ang)}°" for ang in subsector_limits])
plt.tight_layout()
plt.show()

"""#"IDEAL" POINT
Here is where we are going to set the start point to configurate and state the initial conditions for the optimization.
At first we are going to look for the "Ideal Point"; This point is such that the vectors that form the outline of the lasers are tangent to the contour of the target, ensuring that we deposit as much energy as possible as evenly as possible, of course we have to find this point for each ring.
<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-04-08%20105057-Photoroom.png" alt="Imagen 1" width="700">NOT ON SCALE
"""

###################################
# 27.Calculation of the ideal point
###################################
"""
Calculate the minimum distance of the line that passes through P and (X,Y)
to the origin (0,0) using the absolute value of the vector product.
"""
def distLine_to_origin(P, X, Y):

    vx     = X - P[0]
    vy     = Y - P[1]
    norm_v = np.sqrt(vx**2 + vy**2)

    if norm_v == 0:
        return np.inf
    cross_val = P[0]*vy - P[1]*vx

    return abs(cross_val) / norm_v


"""
System of equations that imposes:
1) For the lower beam (xp -> (X,Y)): the line has
cross / norm = -R (tangency below).
2) For the upper beam (xm -> (X,Y)): the line has
cross / norm = R (tangency above).
"""
def system_tangents(vars, xp, xm, R):

    X, Y = vars

                                                                                #For xp (bottom): we want negative cross
    vx_p    = X - xp[0]
    vy_p    = Y - xp[1]
    norm_p  = np.sqrt(vx_p**2 + vy_p**2)
    cross_p = xp[0]*vy_p - xp[1]*vx_p

    eq1 = cross_p/norm_p + R if norm_p != 0 else 1e6

                                                                                #For XM (Superior): We want cross positive
    vx_m    = X - xm[0]
    vy_m    = Y - xm[1]
    norm_m  = np.sqrt(vx_m**2 + vy_m**2)
    cross_m = xm[0]*vy_m - xm[1]*vx_m

    eq2 = cross_m/norm_m - R if norm_m != 0 else 1e6

    return [eq1, eq2]


"""
Solve the system of equations to find (X, Y) where:
- The line that starts from xp (lower) is tangent below (negative cross).
- The line starting from xm (top) is tangent above (positive cross).
In addition, it is verified that (X,Y) is in the desired half-plane (e.g., with X<0 and Y<0
if XP and XM are in the first quadrant).
"""


def find_objective_point(xp, xm, R, initial_guess):

    sol = fsolve(system_tangents, initial_guess, args=(xp, xm, R))
    X_sol, Y_sol = sol

                                                                                # Check the signs:
    vx_p     = X_sol - xp[0]
    vy_p     = Y_sol - xp[1]
    cross_p  = xp[0]*vy_p - xp[1]*vx_p

    vx_m     = X_sol - xm[0]
    vy_m     = Y_sol - xm[1]
    cross_m  = xm[0]*vy_m - xm[1]*vx_m

                                                                                # For xp we want cross_p < 0, for xm we want cross_m > 0.
                                                                                # Also, if xp and xm are in the first quadrant, we force (X,Y) in the third.
    if cross_p >= 0 or cross_m <= 0 or X_sol >= 0 or Y_sol >= 0:
                                                                                # If it is not met, we try with an inverted initial_guess.
        new_guess    = -np.array(initial_guess)
        sol          = fsolve(system_tangents, new_guess, args=(xp, xm, R))
        X_sol, Y_sol = sol

    return np.array([X_sol, Y_sol])


for ring in rings:

  xp    = ring.xp
  xm    = ring.xm
  R     = target.radius

  initial_guess = np.array([-0.01, -0.01])

  ring.objective_new_point = find_objective_point(xp, xm, R, initial_guess)
  print("Nuevo punto objetivo =", ring.objective_new_point)

"""#New Optimized Poits"""

objective_new_points = [
    np.array([-0.03061606 ,-0.07391371]),
    np.array([-0.00805687 ,-0.0139549 ]),
    np.array([-0.01701074 ,-0.01731024]),
    np.array([-0.02121152 ,-0.01779858])
]

for i, ring in enumerate(rings):
    ring.objective_new_point = objective_new_points[i]

np.save('/content/drive/MyDrive/objetive_new_points.npy'  , objective_new_points  )

"""# LONGITUDINAL OFFSET WINDOW

In this section we are going to set a displacement value along the longitudinal axis of the center of each ring, such that we will set a maximum value of 10% loss of intersections, that is, 10% loss of energy.
<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-04-08%20124740-Photoroom.png" alt="Imagen 1" width="700"> NOT ON SCALE

It is really important to calculate appropriately this displacement, because this will lay one of the foundations of our optimization
"""

##################################################
# 28.Calculation of the longitudinal Offset Window
##################################################

"""
Calculates the fraction of beams in a ring that impact the target
when moving the current target point (ring.objective_new_point)
A distance d along 'direction'.
"""

def fraction_hits_for_displacement(ring, d, direction):

    new_obj  = ring.objective_new_point + d * direction
    hits     = 0
    total    = len(ring.R)

    for i in range(total):

        S        = np.array([ring.R[i], ring.Z[i]])
        beam_vec = new_obj - S

        intersections = vector_circle_intersection(
            S[0], S[1], beam_vec[0], beam_vec[1],
            target.center[0], target.center[1], target.radius
        )
        if intersections:
            hits += 1
    return hits / total

def f(d, ring, direction):
                                                                                #f(d) = fraction of impacts - 0.9
    return fraction_hits_for_displacement(ring, d, direction) - 0.9

for ring in rings:
                                                                                #You've got ring.objective_new_point (behind the target)
                                                                                #2) Define the radial direction:
    dir_vec = ring.objective_new_point / np.linalg.norm(ring.objective_new_point)

                                                                                #Search for d that retains 90% impacts
    d_min   = 0.0
    d_max   = 0.001
    val_min = f(d_min, ring, dir_vec)
    val_max = f(d_max, ring, dir_vec)

    if val_min < 0:
        print(f"Ya con d=0 se pierde más de un 10% en el anillo {ring.color}.")
        continue

                                                                                #Expand d_max while val_max >= 0
    while val_max >= 0:

        d_max *= 2
        val_max = f(d_max, ring, dir_vec)
        if d_max > 10:
                                                                                #Limit the search
            print(f"No se encontró d_max que baje de 0.9 en el anillo {ring.color}.")
            break

    if val_max < 0:
        d_allowed = bisect(f, d_min, d_max, args=(ring, dir_vec))
        ring.allowed_displacement = d_allowed
        print(f"Anillo {ring.color}: desplazamiento máximo = {d_allowed:.4f}")

                                                                                # (Optional) Recalculate Intersections and Final Fraction
        final_frac = fraction_hits_for_displacement(ring, d_allowed, dir_vec)
        print(f"   Fracción final de impactos = {final_frac:.4f}")

"""# 2D OFFSET WINDOW

This is another of the most important parts that lay the foundations of an optimization, also allowing a perpendicular displacement with respect to the central axis of the ring, from the ideal point, added to the longitudinal displacement this will give us a displacement window in which each beam can move complying with the stall condition that we impose on it.
<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-04-10%20090635-Photoroom.png" alt="Imagen 1" width="700">
NOT ON SCALE

**Some important notes:**

* The % of losses are selected by us.

* If the percentage of losses allowed is increased, the optimizer will have more freedom so that it can find better solutions, at the cost of losing energy in the process

* We need to limit the negative longitudinal displacement, because otherwise the optimizer will "cheat" looking for solutions with a minimum energy deviation in exchange for leaving areas without energy, which we are not interested in.
"""

##################################################
# 29.Calculation of the longitudinal Offset Window
##################################################

"""
Calculate the fraction of impacts by shifting the target point:
new_obj = ring.objective_new_point + d_long*u + d_perp*v.
The intersection of each beam with the target is evaluated.
"""

def fraction_hits_displacement_2d(ring, d_long, d_perp, u, v, target_radius):   # Function to calculate the impact fraction for a 2D offset

    new_obj   = ring.objective_new_point + d_long * u + d_perp * v
    hits      = 0
    total     = len(ring.R)

    for i in range(total):

        S        = np.array([ring.R[i], ring.Z[i]])
        beam_vec = new_obj - S
        inters   = vector_circle_intersection(S[0], S[1], beam_vec[0], beam_vec[1],
                                            0, 0, target_radius)
        if inters:
            hits += 1
    return hits / total

"""
To define the addresses:
u: longitudinal direction (we use, for example, the direction of the ideal point, which should be behind the target)
Longitudinal (u) and perpendicular (v) directions
"""
u = ring.objective_new_point / np.linalg.norm(ring.objective_new_point)
v = np.array([u[1], -u[0]])                                                     # 90° rotation


                                                                                # Symmetrical search range
d_long_vals = np.linspace(-0.02, 0.05, 200)
d_perp_vals = np.linspace(-0.01, 0.01, 200)

D_long, D_perp = np.meshgrid(d_long_vals, d_perp_vals)
Frac           = np.zeros_like(D_long)

for i in range(D_long.shape[0]):
    for j in range(D_long.shape[1]):
        frac = fraction_hits_displacement_2d(ring,
                                             D_long[i,j],
                                             D_perp[i,j],
                                             u,
                                             v,
                                             target.radius)
        Frac[i,j] = frac




plt.figure           (figsize=(6,6))
CS = plt.contour     (D_long, D_perp, Frac, levels=[0.9], colors='r')
plt.clabel           (CS, inline=1, fontsize=10)
plt.xlabel           ("d_long (m)")
plt.ylabel           ("d_perp (m)")
plt.title            ("Región de búsqueda: fracción de impactos = 0.9 (Elipse completa)")
plt.grid             (True)
plt.show             ()

######################
# 30. Save the results
######################

np.save('/content/drive/MyDrive/D_long.npy'  , D_long  )
np.save('/content/drive/MyDrive/D_perp.npy'  , D_perp  )
np.save('/content/drive/MyDrive/Frac.npy'    , Frac    )