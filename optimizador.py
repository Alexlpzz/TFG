# -*- coding: utf-8 -*-
"""Optimizador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pswJLRBFC1A4HXY5ZzYuXuuNctL5ryQJ

#IMPORTANT NOTES TO KEEP IN MIND
* The previously made program must have been executed in its entirety, so that many of the results obtained are saved on a drive that is later imported here, so as not to be redundant with the calculations.

* Again, be careful with the longitudinal negative displacement, if we exceed a certain value the optimizer will "cheat".

* All graphics and visual content that helps comprehension but not calculations have been removed from this script, with the aim of a higher execution speed, in order to contrast the results the Objective_Points obtained must be pasted into the first script.

#HOW DOES IT WORK ?
The central idea of both methods is to make the energy deposited on a target as uniform as possible. To do this, the positions of the target points associated with each ring are adjusted by modifying the initial position (ideal point) by means of displacements. Uniformity is quantified by calculating the standard deviation of the deposited energy, obtained from a simulation process that evaluates the interaction between the laser beams and the target (see function energy_depose).

#1D OPTIMIZATION
The 1D optimization approach focuses on a single degree of freedom: the longitudinal displacement along the line connecting the ring center to the ideal target point. Its operation is as follows:



1.   **Calculation of the Displaced Point**:
The function displaced_point_along_central_ray(ideal_point, ring_center, d) computes a new target point by shifting it along the direction from the ring center toward the ideal point. The displacement parameter d is added to the original distance along this direction. This method is sufficient when the necessary correction is assumed to be solely along that line.


2.  **Definition of the Optimization Objective**:
The objective_single function evaluates a vector of displacements (one per ring). For each ring:

* The new target point is calculated using the displacement function.

* The energy deposited at the new point is computed with the energy_depose function.

* The uniformity is measured as the standard deviation of the energy values, which serves as the cost (objective) to be minimized.


3.   **Optimization Process**:
Differential evolution is used (via the optimize_displacements function) to search through the possible displacement values within their allowed ranges. The algorithm finds the set of optimal displacements that minimizes the standard deviation of the deposited energy, thereby leading to a more uniform energy distribution.



<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-04-10%20110646-Photoroom.png" alt="Imagen 1" width="700">

#2D OPTIMIZATION

The 2D optimizer extends the model by allowing adjustments in both the longitudinal (d_long) and transverse (d_perp) directions relative to the line connecting the ring center to the ideal target point. This provides greater flexibility for achieving uniform energy deposition, while also incorporating additional physical constraints. Its process is outlined below:


1.   **Extraction of Geometrical Constraints:**
Pre-calculated data (such as D_long, D_perp, and Frac) are used to extract a contour (for example, at the level Frac = 0.9). This contour defines a polygon that delimits the feasible range of displacement values. The function penalty_contour assigns a high cost when the displacement pair (d_long, d_perp) falls outside this polygon.

2.   **Calculation of the Displaced Point in 2D:**
The function displaced_point_final_generic(ideal_point, ring_center, d_long, d_perp) computes the new target point by:

* Adding a component in the original direction (from the ring center to the ideal point) increased by d_long.

* Adding a perpendicular component (obtained by rotating the direction by 90°) scaled by d_perp. This approach allows the point to be shifted both along and perpendicular to the original direction.

3.  **Definition of the Objective with Penalty:**
The objective_single_penalty function evaluates a vector of parameters (two per ring) by:

* Computing the new target points using both d_long and d_perp values.

* Calculating the energy at those points using the energy_depose function.

* Adding a penalty cost if the displacement falls outside the allowed polygon. The overall cost is the sum of the energy standard deviation and the penalty, and this cost is what the optimizer seeks to minimize.

4.  **Optimization Process:**
The function optimize_displacements_penalty applies differential evolution within rectangular bounds (defined by the contour values: d_long_min, d_long_max, d_perp_min, and d_perp_max). The optimizer searches for the displacement parameters that minimize the combined cost function, thus achieving a uniform energy distribution while respecting the physical constraints.


<img src="https://raw.githubusercontent.com/Alexlpzz/TFG/refs/heads/main/Captura%20de%20pantalla%202025-04-10%20111027-Photoroom.png" alt="Imagen 1" width="1100">

#INICILIZATION
"""

import argparse
import numpy as np
import sympy as sp



import matplotlib.pyplot as plt
import matplotlib.patches as patches
import scipy.stats as spyce
from sympy import symbols, integrate
from scipy.integrate import quad
from scipy.optimize import brentq
from scipy.optimize import fsolve
from scipy.optimize import minimize
from scipy.interpolate import make_interp_spline
from scipy.optimize import differential_evolution
from collections import defaultdict
from google.colab import drive
from shapely.geometry import Polygon, Point
drive.mount('/content/drive')

"""#Packaging
Packaging of all the equations, parts and functions necessary for the calculation of the final energy deposited in the sphere and its coordinates
"""

##############
# 1. packaging
##############
def energy_depose(objective_points):

    chamber = argparse.Namespace(center=np.array([0, 0]), radius=5)
    target = argparse.Namespace(center=np.array([0, 0]), radius=1.6285e-3)
    window = argparse.Namespace(length=0.20)


    ring1 = argparse.Namespace(theta=np.radians(22.5), beams=4, point=objective_points[0], color='green', beans=4)
    ring2 = argparse.Namespace(theta=np.radians(30), beams=4, point=objective_points[1], color='red', beans=4)
    ring3 = argparse.Namespace(theta=np.radians(44.5), beams=8, point=objective_points[2], color='violet', beans=8)
    ring4 = argparse.Namespace(theta=np.radians(50), beams=8, point=objective_points[3], color='blue', beans=8)

    rings = [ring1, ring2, ring3, ring4]


    for ring in rings:
        ring.center = chamber.radius * np.array([np.sin(ring.theta), np.cos(ring.theta)])
        n = ring.center - chamber.center
        d = np.array([n[1], -n[0]])
        d /= np.linalg.norm(d)

        ring.xp = ring.center + window.length * d
        ring.xm = ring.center - window.length * d


    vector_discretizado = np.load('/content/drive/MyDrive/vector_discretizado.npy')
    puntos_corte= np.array(vector_discretizado)
    laser_discretitation = np.load('/content/drive/MyDrive/num_discretizado.npy')


    for ring in rings:
        ring.Alpha_r = ((ring.xp[0] + ring.xm[0]) / 2)
        ring.Betha_r = ((ring.xp[0] - ring.xm[0]) / 2)
        ring.Alpha_z = ((ring.xp[1] + ring.xm[1]) / 2)
        ring.Betha_z = ((ring.xp[1] - ring.xm[1]) / 2)
        ring.R = ring.Alpha_r + ring.Betha_r * np.array(puntos_corte)
        ring.Z = ring.Alpha_z + ring.Betha_z * np.array(puntos_corte)

    laser = argparse.Namespace()
    for ring in rings:
        ring.vx = np.array(ring.point[0] - ring.R)
        ring.vy = np.array(ring.point[1] - ring.Z)

    laser.vx = np.concatenate([ring.vx for ring in rings])
    laser.vy = np.concatenate([ring.vy for ring in rings])
    laser.R = np.concatenate([ring.R for ring in rings])
    laser.Z = np.concatenate([ring.Z for ring in rings])

    matriz = np.column_stack((laser.R, laser.Z, laser.vx, laser.vy))

    def vector_circle_intersection(x0, y0, vx, vy, xc, yc, R):
        a = vx**2 + vy**2
        b = 2 * (vx * (x0 - xc) + vy * (y0 - yc))
        c = (x0 - xc)**2 + (y0 - yc)**2 - R**2
        disc = b**2 - 4 * a * c

        if disc < 0:
            return []

        sqrt_disc = np.sqrt(disc)
        t1 = (-b + sqrt_disc) / (2 * a)
        t2 = (-b - sqrt_disc) / (2 * a)

        points = []
        if t1 >= 0:
            x_inter1 = x0 + t1 * vx
            y_inter1 = y0 + t1 * vy
            points.append((x_inter1, y_inter1))
        if t2 >= 0:
            x_inter2 = x0 + t2 * vx
            y_inter2 = y0 + t2 * vy
            points.append((x_inter2, y_inter2))

        return points

    xc, yc = target.center[0], target.center[1]
    R = target.radius
    intersection_x = []
    intersection_y = []

    for ring in rings:
        ring.intersection_x = []
        ring.intersection_y = []

    rows_per_ring = laser_discretitation

    for i, vector in enumerate(matriz):
        x0, y0, vx, vy = vector
        ring_index = i // rows_per_ring
        if ring_index >= len(rings):
            break

        ring = rings[ring_index]
        intersection_points_target = vector_circle_intersection(x0, y0, vx, vy, xc, yc, R)

        if intersection_points_target:

            first_intersection = min(intersection_points_target, key=lambda p: (p[0] - x0)**2 + (p[1] - y0)**2)


            ring.intersection_x.append(first_intersection[0])
            ring.intersection_y.append(first_intersection[1])


    for ring in rings:

        ring.intersection_y = np.array(ring.intersection_y, dtype=float)
        ring.intersection_x = np.array(ring.intersection_x, dtype=float)

        ring.X_sym_x = ring.intersection_x
        ring.Y_sym_x = (-1) * ring.intersection_y

        ring.X_sym_y = (-1) * ring.intersection_x
        ring.Y_sym_y = ring.intersection_y

        ring.X_sym_o = (-1) * ring.intersection_x
        ring.Y_sym_o = (-1) * ring.intersection_y



    Laser_energy = 9

    for ring in rings:
        ring.energy_total = Laser_energy * ring.beans
        ring.energy_per_point = []
        for ix, iy in zip(ring.intersection_x, ring.intersection_y):

            beam_vec = ring.point - np.array([ix, iy])
            beam_vec_norm = np.linalg.norm(beam_vec)
            beam_dir = beam_vec / beam_vec_norm if beam_vec_norm != 0 else np.array([0, 0])

            normal = np.array([ix, iy]) - target.center
            normal_norm = np.linalg.norm(normal)
            normal_unit = normal / normal_norm if normal_norm != 0 else np.array([0, 0])

            cos_incidence = abs(np.dot(beam_dir, normal_unit))
            energy_point = (ring.energy_total / laser_discretitation) * cos_incidence
            ring.energy_per_point.append(energy_point)



    intersecciones_rings = [[] for _ in rings]
    energias_rings = [[] for _ in rings]


    for ring_index, ring in enumerate(rings):

        for i, (x, y) in enumerate(zip(ring.intersection_x, ring.intersection_y)):
            intersecciones_rings[ring_index].append((x, y))
            energias_rings[ring_index].append(ring.energy_per_point[i])


        for i, (x, y) in enumerate(zip(ring.X_sym_x, ring.Y_sym_x)):
            intersecciones_rings[ring_index].append((x, y))
            energias_rings[ring_index].append(ring.energy_per_point[i])


        for i, (x, y) in enumerate(zip(ring.X_sym_y, ring.Y_sym_y)):
            intersecciones_rings[ring_index].append((x, y))
            energias_rings[ring_index].append(ring.energy_per_point[i])


        for i, (x, y) in enumerate(zip(ring.X_sym_o, ring.Y_sym_o)):
            intersecciones_rings[ring_index].append((x, y))
            energias_rings[ring_index].append(ring.energy_per_point[i])



    # Combinar todas las intersecciones y energías
    all_points = []
    all_energies = []

    for intersecciones, energias in zip(intersecciones_rings, energias_rings):
        all_points.extend(intersecciones)
        all_energies.extend(energias)

    all_points = np.array(all_points)
    all_energies = np.array(all_energies)

    # Ángulos en grados respecto al centro, con 0° hacia arriba y sentido horario
    angles = (90 - np.degrees(np.arctan2(all_points[:,1], all_points[:,0]))) % 360

    # Definir el primer sector (ejemplo de 0° a 90°) y dividirlo en 6 subsectores
    sector_start = 0
    sector_end = 90
    num_subsectores = np.load('/content/drive/MyDrive/subsectores.npy')
    subsector_limits = np.linspace(sector_start, sector_end, num_subsectores + 1)

    # Filtrar puntos que caen dentro del primer sector
    mask_sector = (angles >= sector_start) & (angles < sector_end)
    angles_sector = angles[mask_sector]
    energies_sector = all_energies[mask_sector]
    intersecciones_sector_1 = all_points[mask_sector]

    # Inicializar energía por subsector
    energy_per_subsector = np.zeros(num_subsectores)

    # Sumar energías por subsector
    for i in range(num_subsectores):
        mask_sub = (angles_sector >= subsector_limits[i]) & (angles_sector < subsector_limits[i+1])
        energy_per_subsector[i] = np.sum(energies_sector[mask_sub])

    area_subsectores = []

    for i in range(len(subsector_limits) - 1):
        theta1 = np.deg2rad(subsector_limits[i])
        theta2 = np.deg2rad(subsector_limits[i+1])

        area = 2 * np.pi * target.radius**2 * (np.cos(theta1) - np.cos(theta2))
        area_subsectores.append(area)



    intensity_per_sector = []

    for i in range(num_subsectores):
        intensidad = energy_per_subsector[i] / area_subsectores[i]
        intensity_per_sector.append(intensidad)

    energy_vector = np.array(intensity_per_sector)
    return energy_vector

"""#TEST
To ensure the packcaging was successful
"""

##############
# 2. Testing
##############


objective_points_test = np.array([
    [-0.01572036 , -0.03795231] ,
    [-0.02053964 , -0.0355757 ] ,
    [-0.02879285 , -0.02929981] ,
    [-0.03146855 , -0.02640525]
])
final_energy = energy_depose(objective_points_test)

print(" Energía depositada en cada punto:", final_energy)
print(len(final_energy))

"""#Optimización con solo un grado de libertad

"""

####################
# 2. Optimization 1D
####################


"""
Calculates the new longitudinally shifted target point.
It is assumed that the offset is applied along the direction that
It goes from ring_center to ideal_point, increasing the original distance by D.
"""

def displaced_point_along_central_ray(ideal_point, ring_center, d):

    direction  = ideal_point - ring_center
    norm_dir   = np.linalg.norm(direction)

    if norm_dir == 0:
        return ideal_point
    unit_direction = direction / norm_dir

                                                                                # The new point is obtained by advancing from ring_center the original distance + d
    return ring_center + (norm_dir + d) * unit_direction

"""
Measure non-uniformity using standard deviation.
"""

def uniformity_measure(energy_array):

      std = np.std(energy_array)
      peak_to_valley = np.max(energy_array) - np.min(energy_array)
      return std + 0.3 * peak_to_valley

"""
Params: Vector of 4 displacements, one for each ring, in the range [0, dmax_i].
The new longitudinally displaced target points are reconstructed and
The uniformity of the energy deposited is evaluated.
"""

def objective_single(params, ring_ideal_points, ring_centers, ring_dmax):

    new_objective_points = []

    for i in range(len(ring_ideal_points)):

        d_val  = min(params[i], ring_dmax[i])
        new_pt = displaced_point_along_central_ray(ring_ideal_points[i], ring_centers[i], d_val)

        new_objective_points.append(new_pt)

    new_objective_points = np.array(new_objective_points)
    energy_vector        = energy_depose(new_objective_points)
    cost                 = uniformity_measure(energy_vector)

    if np.any(np.isnan(energy_vector)):
        return 1e6
    return cost


"""
Optimizes longitudinal displacements so that the energy deposited
is as uniform as possible.
- ring_ideal_points: arrays of ideal points for each ring (shape (4,2)).
- ring_centers: array of centers of each ring (shape (4,2)).
- ring_dmax: list with the maximum longitudinal displacement allowed for each ring.
"""


def optimize_displacements(ring_ideal_points, ring_centers, ring_dmax):

                                                                                # Define bounds for each ring: (0, dmax_i)
    bounds = [(-d_max, d_max) for d_max in ring_dmax]
    result = differential_evolution(
        objective_single,
        bounds,
        args=(ring_ideal_points, ring_centers, ring_dmax),
        strategy='best1bin',
        popsize=20,
        maxiter=250,
        tol=1e-6,
        disp=True
    )
    return result



ring_ideal_points = ring_ideal_points = np.load('/content/drive/MyDrive/objetive_new_points.npy', allow_pickle=True)

ring_centers = np.array([
    [1.91341716, 4.61939766],
    [2.5,         4.33012702],
    [3.50454632,  3.56625225],
    [3.83022222,  3.21393805],
])

ring_dmax = [0.00145, 0.0435, 0.0365, 0.0335]

result = optimize_displacements(ring_ideal_points, ring_centers, ring_dmax)
print("Estado de la optimización:", result.message)
print("Mejor coste (desviación estándar):", result.fun)
print("Desplazamientos óptimos:", result.x)

                                                                                # Reconstruct the new optimal points with longitudinal displacement

best_objective_points = []

for i in range(len(ring_ideal_points)):

    d_val     = result.x[i]
    new_pt    = displaced_point_along_central_ray(ring_ideal_points[i], ring_centers[i], d_val)

    best_objective_points.append(new_pt)

best_objective_points = np.array(best_objective_points)
print("Puntos objetivo finales:", best_objective_points)

final_energy = energy_depose(best_objective_points)
print("Vector final de energía:", final_energy)

"""#Optimización con 2 grados de libertad"""

####################
# 2. Optimization 2D
####################

                                                                                #Load calculated offsets
D_long   = np.load('/content/drive/MyDrive/D_long.npy' )
D_perp   = np.load('/content/drive/MyDrive/D_perp.npy' )
Frac     = np.load('/content/drive/MyDrive/Frac.npy'   )


                                                                                #Extract the contour (contour line Frac=0.9)

CS = plt.contour(D_long, D_perp, Frac, levels=[0.9])
plt.close()


                                                                                # CS.allsegs is a list per level; We take the first segment of the 0.9 level.
                                                                                # Depending on your contour there may be more than one segment; here we use the first one.
seg = CS.allsegs[0][0]

print("Segmento extraído (antes de cerrar):", seg.shape)

                                                                                # Make sure the outline is closed (the first and last stitches are equal)
if not np.allclose(seg[0], seg[-1]):
    seg = np.vstack([seg, seg[0]])
print("Segmento cerrado:", seg.shape)

                                                                                # Create the Contour Polygon
polygon_90 = Polygon(seg)

                                                                                #Extracting the rectangular bounds from the outline
d_long_min = seg[:, 0].min()
d_long_max = seg[:, 0].max()
d_perp_min = seg[:, 1].min()
d_perp_max = seg[:, 1].max()

print("Bounds extraídos del contorno:")
print(f"  d_long ∈ [{d_long_min:.4f}, {d_long_max:.4f}]")
print(f"  d_perp ∈ [{d_perp_min:.4f}, {d_perp_max:.4f}]")


"""
Penalty function: returns 0 if the point
 (d_long, d_perp) is within the boundary, K otherwise.
"""

def penalty_contour(d_long, d_perp, polygon, K=1e8):
    pt = Point(d_long, d_perp)
    if polygon.contains(pt):
        return 0.0
    else:
        return K

"""
Calculate the new target point for a ring using:
- d_long: displacement along the direction between ring_center and ideal_point.
- d_perp: displacement in the direction perpendicular to that axis.
"""

def displaced_point_final_generic(ideal_point, ring_center, d_long, d_perp):

    direction   = ideal_point - ring_center
    norm_dir    = np.linalg.norm(direction)
    if norm_dir == 0:
        return ideal_point

    u         = direction / norm_dir
    v         = np.array([u[1], -u[0]])
    new_point = ring_center + (norm_dir + d_long) * u + d_perp * v

    return new_point


"""
Params: 2*n vector parameters for n rings:
[d_long_1, d_perp_1, d_long_2, d_perp_2, ..., d_long_n, d_perp_n]
The new target point for each ring is calculated, uniformity is evaluated
(standard deviation) of the energy deposited and a penalty is added if the
solution goes out of contour (polygon).
"""


def objective_single_penalty(params, ring_ideal_points, ring_centers, ring_dmax_long, ring_dmax_perp, polygon):

    n                    = len(ring_ideal_points)
    new_objective_points = []
    penalty_total        = 0.0

    for i in range(n):

        d_long = min(params[2*i], ring_dmax_long[i])
        d_perp = min(params[2*i+1], ring_dmax_perp[i])

        penalty_total += penalty_contour(d_long, d_perp, polygon)
        new_pt = displaced_point_final_generic(ring_ideal_points[i], ring_centers[i], d_long, d_perp)

        new_objective_points.append(new_pt)

    new_objective_points = np.array(new_objective_points)
    energy_vector        = energy_depose(new_objective_points)
    cost                 = np.std(energy_vector) + penalty_total

    if np.any(np.isnan(energy_vector)):
        return 1e6
    return cost


"""
Optimizes the displacements (d_long, d_perp) for each ring using differential_evolution.
Rectangular bounds extracted from the contour are used and solutions are penalized
that they step out of that contour.
"""

def optimize_displacements_penalty(ring_ideal_points, ring_centers, ring_dmax_long, ring_dmax_perp, polygon):

    n      = len(ring_ideal_points)
    bounds = []

    for i in range(n):
        bounds.append((d_long_min, d_long_max))
        bounds.append((d_perp_min, d_perp_max))
    result = differential_evolution(
        objective_single_penalty,
        bounds,
        args=(ring_ideal_points, ring_centers, ring_dmax_long, ring_dmax_perp, polygon),
        strategy='best1bin',
        popsize=20,
        maxiter=350,
        tol=1e-6,
        disp=True
    )
    return result


"""
Input data for optimization
"""

                                                                                # These values must be pre-calculated:
ring_ideal_points = np.array([
    [-0.01572036 , -0.03795231],
    [-0.02053964 , -0.0355757 ],
    [-0.02879285 , -0.02929981],
    [-0.03146855 , -0.02640525]
])
ring_centers = np.array([
    [1.91341716, 4.61939766],
    [2.5,         4.33012702],
    [3.50454632,  3.56625225],
    [3.83022222,  3.21393805]
])

                                                                                # Maximum permitted (physical) displacements for each ring:
ring_dmax_long = [0.0194, 0.0194, 0.0194, 0.0194]
ring_dmax_perp = [0.002, 0.002, 0.002, 0.002]


"""
Run the optimizer
"""


result = optimize_displacements_penalty(ring_ideal_points, ring_centers,
                                        ring_dmax_long, ring_dmax_perp,
                                        polygon_90)
print("Estado de la optimización:", result.message)
print("Mejor coste (std + penalización):", result.fun)
print("Parámetros óptimos:", result.x)

                                                                                # Reconstruct the new objective points using the optimal parameters:
n = len(ring_ideal_points)
best_objective_points = []
for i in range(n):
    d_long = result.x[2*i]
    d_perp = result.x[2*i+1]
    new_pt = displaced_point_final_generic(ring_ideal_points[i], ring_centers[i], d_long, d_perp)
    best_objective_points.append(new_pt)
best_objective_points = np.array(best_objective_points)
print("Puntos objetivo finales:", best_objective_points)

final_energy = energy_depose(best_objective_points)
print("Vector final de energía:", final_energy)
print("Desviación estándar final:", np.std(final_energy))